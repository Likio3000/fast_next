--- START FILE: .gitignore ---
# OS & IDE
.DS_Store
Thumbs.db
.vscode/
.idea/
*.swp
*~

# Python
__pycache__/
**/__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so

# Python packaging
build/
dist/
*.egg-info/
*.egg
pip-wheel-metadata/

# Virtual environments
.venv/
venv/
backend/.venv/

# Environment variables
.env
.env.*
backend/.env

# Testing & Coverage
.pytest_cache/
coverage/
htmlcov/
.coverage
.coverage.*

# Logs
logs/
*.log

# Node.js
node_modules/
frontend/node_modules/

# Lock files
package-lock.json
yarn.lock
pnpm-lock.yaml

# Next.js
.next/
frontend/.next/
out/
frontend/out/
build/
frontend/build/
*.tsbuildinfo
next-env.d.ts

# Vercel
.vercel/
frontend/.vercel/

# Miscellaneous
*.pem

--- END FILE: .gitignore ---

--- START FILE: sc2_output.txt ---
--- START FILE: .gitignore ---
# OS & IDE
.DS_Store
Thumbs.db
.vscode/
.idea/
*.swp
*~

# Python
__pycache__/
**/__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so

# Python packaging
build/
dist/
*.egg-info/
*.egg
pip-wheel-metadata/

# Virtual environments
.venv/
venv/
backend/.venv/

# Environment variables
.env
.env.*
backend/.env

# Testing & Coverage
.pytest_cache/
coverage/
htmlcov/
.coverage
.coverage.*

# Logs
logs/
*.log

# Node.js
node_modules/
frontend/node_modules/

# Lock files
package-lock.json
yarn.lock
pnpm-lock.yaml

# Next.js
.next/
frontend/.next/
out/
frontend/out/
build/
frontend/build/
*.tsbuildinfo
next-env.d.ts

# Vercel
.vercel/
frontend/.vercel/

# Miscellaneous
*.pem

--- END FILE: .gitignore ---

--- START FILE: sc2_output.txt ---
--- START FILE: .gitignore ---
# OS & IDE
.DS_Store
Thumbs.db
.vscode/
.idea/
*.swp
*~

# Python
__pycache__/
**/__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so

# Python packaging
build/
dist/
*.egg-info/
*.egg
pip-wheel-metadata/

# Virtual environments
.venv/
venv/
backend/.venv/

# Environment variables
.env
.env.*
backend/.env

# Testing & Coverage
.pytest_cache/
coverage/
htmlcov/
.coverage
.coverage.*

# Logs
logs/
*.log

# Node.js
node_modules/
frontend/node_modules/

# Lock files
package-lock.json
yarn.lock
pnpm-lock.yaml

# Next.js
.next/
frontend/.next/
out/
frontend/out/
build/
frontend/build/
*.tsbuildinfo
next-env.d.ts

# Vercel
.vercel/
frontend/.vercel/

# Miscellaneous
*.pem

--- END FILE: .gitignore ---

--- START FILE: sc2.py ---
import os
import pyperclip
import argparse

try:
    import pathspec
except ImportError:
    pathspec = None
    print("Warning: 'pathspec' library not found. .gitignore support will be disabled.")

# --- Configuration ---

# Add file extensions you want to include (lowercase)
ALLOWED_EXTENSIONS = {
    '.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.htm', '.css', '.scss', '.sass',
    '.json', '.yaml', '.yml', '.xml', '.md', '.txt', '.sh', '.bash', '.zsh',
    '.java', '.cs', '.cpp', '.c', '.h', '.hpp', '.go', '.rs', '.php', '.rb',
    '.sql'
}

# Add specific full filenames to include regardless of extension
ALLOWED_FILENAMES = {
    'dockerfile', 'docker-compose.yml', '.env.example', '.gitignore',
    'requirements.txt', 'package.json', 'composer.json', 'pom.xml', 'gemfile'
}

# Add directory names to completely exclude (lowercase)
EXCLUDED_DIRS = {
    '.git', '.svn', '.hg', '__pycache__', 'node_modules', 'vendor', 'egg-info',
    'target', 'build', 'dist', 'out', 'bin', 'obj', '.vscode', '.idea', '.next', '.venv', 'venv', '.env', 'env'
}
EXCLUDED_DIRS = {d.lower() for d in EXCLUDED_DIRS}

# Add specific filenames to exclude (lowercase)
EXCLUDED_FILES = {
    '.env', 'credentials.json', 'secrets.yaml',
    'package-lock.json', 'yarn.lock', 'composer.lock'
}
EXCLUDED_FILES = {f.lower() for f in EXCLUDED_FILES}

# Maximum individual file size to include (in bytes)
MAX_FILE_SIZE_BYTES = 1 * 1024 * 1024  # 1 MB limit per file


def load_gitignore(project_dir):
    """
    Load .gitignore from the project directory if available.
    Returns a compiled pathspec object or None.
    """
    gitignore_path = os.path.join(project_dir, '.gitignore')
    if os.path.exists(gitignore_path) and pathspec:
        try:
            with open(gitignore_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            spec = pathspec.PathSpec.from_lines('gitwildmatch', lines)
            print("Loaded .gitignore patterns.")
            return spec
        except Exception as e:
            print(f"Error loading .gitignore: {e}")
    return None


def collect_project_contents(project_dir):
    """
    Collects relevant text file contents from a project directory.
    """
    all_contents = []
    project_dir = os.path.abspath(project_dir)

    if not os.path.isdir(project_dir):
        return f"Error: Directory not found: {project_dir}", False

    print(f"Scanning directory: {project_dir}")
    print("Ignoring directories:", EXCLUDED_DIRS)
    print("Ignoring files:", EXCLUDED_FILES)
    print("Allowed extensions:", ALLOWED_EXTENSIONS)
    print("Allowed filenames:", ALLOWED_FILENAMES)
    print("---")

    gitignore_spec = load_gitignore(project_dir)

    total_files_scanned = excluded_by_type = excluded_by_name = excluded_by_dir = 0
    excluded_by_size = excluded_by_gitignore = excluded_egg_info = read_errors = included_files_count = 0

    for root, dirs, files in os.walk(project_dir, topdown=True):
        # Filter out excluded dirs immediately
        dirs[:] = [d for d in dirs if d.lower() not in EXCLUDED_DIRS]

        # Skip entire directory if any segment matches excluded dirs
        rel_root = os.path.relpath(root, project_dir)
        segments = [seg.lower() for seg in rel_root.split(os.sep) if seg]
        if set(segments) & EXCLUDED_DIRS:
            excluded_by_dir += len(dirs) + len(files)
            dirs[:] = []
            continue

        for filename in files:
            total_files_scanned += 1
            file_path = os.path.join(root, filename)
            rel_path = os.path.relpath(file_path, project_dir)

            # Skip egg-info files
            if 'egg-info' in filename.lower():
                excluded_egg_info += 1
                continue

            # Exclude specific filenames
            if filename.lower() in EXCLUDED_FILES:
                excluded_by_name += 1
                continue

            # Check extension or specific filename
            ext = os.path.splitext(filename)[1].lower()
            if ext not in ALLOWED_EXTENSIONS and filename.lower() not in ALLOWED_FILENAMES:
                excluded_by_type += 1
                continue

            # .gitignore patterns
            if gitignore_spec and gitignore_spec.match_file(rel_path):
                excluded_by_gitignore += 1
                continue

            # Size check
            try:
                size = os.path.getsize(file_path)
                if size > MAX_FILE_SIZE_BYTES:
                    excluded_by_size += 1
                    continue
            except OSError:
                read_errors += 1
                continue

            # Read content
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                header = f"--- START FILE: {rel_path} ---\n"
                footer = f"\n--- END FILE: {rel_path} ---\n\n"
                all_contents.append(header + content + footer)
                included_files_count += 1
            except Exception:
                read_errors += 1

    # Summary
    print("---")
    print(f"Total scanned: {total_files_scanned}")
    print(f"Included files: {included_files_count}")
    print(f"Excluded by type: {excluded_by_type}")
    print(f"Excluded by name: {excluded_by_name}")
    print(f"Excluded by dir: {excluded_by_dir}")
    print(f"Excluded by size: {excluded_by_size}")
    print(f"Excluded by gitignore: {excluded_by_gitignore}")
    print(f"Excluded egg-info: {excluded_egg_info}")
    print(f"Read errors: {read_errors}")
    print("---")

    if not all_contents:
        return "No relevant files found or collected.", True

    return "".join(all_contents), True


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Collect contents of text files in a project and copy to clipboard."
    )
    parser.add_argument("project_dir", nargs='?', default='.', help="Project directory (default: current)")
    parser.add_argument('-t', '--tests', action='store_true', help="Include 'tests/' directory")
    parser.add_argument('-w', '--write', action='store_true', help="Write output to 'sc2_output.txt' in project root")
    args = parser.parse_args()

    # By default exclude tests unless -t is provided
    if not args.tests:
        EXCLUDED_DIRS.add('tests')

    output, success = collect_project_contents(args.project_dir)
    if success:
        # Always copy to clipboard
        try:
            pyperclip.copy(output)
            print(f"Copied {len(output)} characters to clipboard.")
        except Exception as e:
            print(f"Warning: Could not copy to clipboard: {e}")

        # Optionally write to file
        if args.write:
            out_path = os.path.join(os.path.abspath(args.project_dir), 'sc2_output.txt')
            try:
                with open(out_path, 'w', encoding='utf-8') as f:
                    f.write(output)
                print(f"Written output to {out_path}")
            except Exception as e:
                print(f"Error writing output file: {e}")
    else:
        print(output)

--- END FILE: sc2.py ---

--- START FILE: backend/requirements.txt ---
fastapi
uvicorn[standard]
openai-agents
python-dotenv
--- END FILE: backend/requirements.txt ---

--- START FILE: backend/app/__init__.py ---

--- END FILE: backend/app/__init__.py ---

--- START FILE: backend/app/main.py ---
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from agents import Agent, Runner, function_tool
import os, asyncio

app = FastAPI()

# Allow requests from the Next.js dev server
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Example Python function exposed as a tool
@function_tool
def get_current_year() -> int:
    """Return the current year."""
    from datetime import datetime
    return datetime.now().year

class ChatRequest(BaseModel):
    user_message: str

@app.post("/chat")
async def chat(req: ChatRequest):
    # Define a simple agent – fine for early development; you can optimize later
    assistant = Agent(
        name="Assistant",
        instructions="You are a helpful assistant. Use provided tools when helpful.",
        tools=[get_current_year],
        model="gpt-4.1-nano"  # CHOSEN MODEL CHODEN MODEL CHODEN MODEL CHOSEN MODEL
    )

    try:
        # Runner.run is async; returns an AgentResult with .final_output
        result = await Runner.run(assistant, input=req.user_message)
        return {"reply": result.final_output}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
--- END FILE: backend/app/main.py ---

--- START FILE: frontend/next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

--- END FILE: frontend/next.config.ts ---

--- START FILE: frontend/README.md ---
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

--- END FILE: frontend/README.md ---

--- START FILE: frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.3.1"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "@eslint/eslintrc": "^3"
  }
}

--- END FILE: frontend/package.json ---

--- START FILE: frontend/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

--- END FILE: frontend/tsconfig.json ---

--- START FILE: frontend/app/page.tsx ---
// frontend/app/page.tsx
'use client';

import { useState } from 'react';

interface Message {
  role: 'user' | 'assistant';
  text: string;
}

export default function Home() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');

  const send = async () => {
    if (!input.trim()) return;
    const next = [...messages, { role: 'user', text: input }];
    setMessages(next);
    setInput('');

    const res = await fetch('http://localhost:8000/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ user_message: input }),
    });

    const { reply } = await res.json();
    setMessages([...next, { role: 'assistant', text: reply }]);
  };

  return (
    <main className="flex flex-col h-screen p-4">
      <section className="flex-1 overflow-y-auto space-y-2">
        {messages.map((m, i) => (
          <p key={i} className={m.role === 'user' ? 'text-blue-500' : 'text-green-500'}>
            <strong>{m.role}:</strong> {m.text}
          </p>
        ))}
      </section>

      <section className="flex pt-4">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && send()}
          className="flex-1 border rounded p-2"
          placeholder="Ask me anything…"
        />
        <button onClick={send} className="ml-2 border rounded px-3">
          Send
        </button>
      </section>
    </main>
  );
}

--- END FILE: frontend/app/page.tsx ---

--- START FILE: frontend/app/globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

--- END FILE: frontend/app/globals.css ---

--- START FILE: frontend/app/layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

--- END FILE: frontend/app/layout.tsx ---


--- END FILE: sc2_output.txt ---

--- START FILE: sc2.py ---
import os
import pyperclip
import argparse

try:
    import pathspec
except ImportError:
    pathspec = None
    print("Warning: 'pathspec' library not found. .gitignore support will be disabled.")

# --- Configuration ---

# Add file extensions you want to include (lowercase)
ALLOWED_EXTENSIONS = {
    '.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.htm', '.css', '.scss', '.sass',
    '.json', '.yaml', '.yml', '.xml', '.md', '.txt', '.sh', '.bash', '.zsh',
    '.java', '.cs', '.cpp', '.c', '.h', '.hpp', '.go', '.rs', '.php', '.rb',
    '.sql'
}

# Add specific full filenames to include regardless of extension
ALLOWED_FILENAMES = {
    'dockerfile', 'docker-compose.yml', '.env.example', '.gitignore',
    'requirements.txt', 'package.json', 'composer.json', 'pom.xml', 'gemfile'
}

# Add directory names to completely exclude (lowercase)
EXCLUDED_DIRS = {
    '.git', '.svn', '.hg', '__pycache__', 'node_modules', 'vendor', 'egg-info',
    'target', 'build', 'dist', 'out', 'bin', 'obj', '.vscode', '.idea', '.next', '.venv', 'venv', '.env', 'env'
}
EXCLUDED_DIRS = {d.lower() for d in EXCLUDED_DIRS}

# Add specific filenames to exclude (lowercase)
EXCLUDED_FILES = {
    '.env', 'credentials.json', 'secrets.yaml',
    'package-lock.json', 'yarn.lock', 'composer.lock'
}
EXCLUDED_FILES = {f.lower() for f in EXCLUDED_FILES}

# Maximum individual file size to include (in bytes)
MAX_FILE_SIZE_BYTES = 1 * 1024 * 1024  # 1 MB limit per file


def load_gitignore(project_dir):
    """
    Load .gitignore from the project directory if available.
    Returns a compiled pathspec object or None.
    """
    gitignore_path = os.path.join(project_dir, '.gitignore')
    if os.path.exists(gitignore_path) and pathspec:
        try:
            with open(gitignore_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            spec = pathspec.PathSpec.from_lines('gitwildmatch', lines)
            print("Loaded .gitignore patterns.")
            return spec
        except Exception as e:
            print(f"Error loading .gitignore: {e}")
    return None


def collect_project_contents(project_dir):
    """
    Collects relevant text file contents from a project directory.
    """
    all_contents = []
    project_dir = os.path.abspath(project_dir)

    if not os.path.isdir(project_dir):
        return f"Error: Directory not found: {project_dir}", False

    print(f"Scanning directory: {project_dir}")
    #print("Ignoring directories:", EXCLUDED_DIRS)
    print("Ignoring files:", EXCLUDED_FILES)
    print("Allowed extensions:", ALLOWED_EXTENSIONS)
    print("Allowed filenames:", ALLOWED_FILENAMES)
    print("---")

    gitignore_spec = load_gitignore(project_dir)

    total_files_scanned = excluded_by_type = excluded_by_name = excluded_by_dir = 0
    excluded_by_size = excluded_by_gitignore = excluded_egg_info = read_errors = included_files_count = 0

    for root, dirs, files in os.walk(project_dir, topdown=True):
        # Filter out excluded dirs immediately
        dirs[:] = [d for d in dirs if d.lower() not in EXCLUDED_DIRS]

        # Skip entire directory if any segment matches excluded dirs
        rel_root = os.path.relpath(root, project_dir)
        segments = [seg.lower() for seg in rel_root.split(os.sep) if seg]
        if set(segments) & EXCLUDED_DIRS:
            excluded_by_dir += len(dirs) + len(files)
            dirs[:] = []
            continue

        for filename in files:
            total_files_scanned += 1
            file_path = os.path.join(root, filename)
            rel_path = os.path.relpath(file_path, project_dir)

            # Skip egg-info files
            if 'egg-info' in filename.lower():
                excluded_egg_info += 1
                continue

            # Exclude specific filenames
            if filename.lower() in EXCLUDED_FILES:
                excluded_by_name += 1
                continue

            # Check extension or specific filename
            ext = os.path.splitext(filename)[1].lower()
            if ext not in ALLOWED_EXTENSIONS and filename.lower() not in ALLOWED_FILENAMES:
                excluded_by_type += 1
                continue

            # .gitignore patterns
            if gitignore_spec and gitignore_spec.match_file(rel_path):
                excluded_by_gitignore += 1
                continue

            # Size check
            try:
                size = os.path.getsize(file_path)
                if size > MAX_FILE_SIZE_BYTES:
                    excluded_by_size += 1
                    continue
            except OSError:
                read_errors += 1
                continue

            # Read content
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                header = f"--- START FILE: {rel_path} ---\n"
                footer = f"\n--- END FILE: {rel_path} ---\n\n"
                all_contents.append(header + content + footer)
                included_files_count += 1
            except Exception:
                read_errors += 1

    # Summary
    print("---")
    print(f"Total scanned: {total_files_scanned}")
    print(f"Included files: {included_files_count}")
    print(f"Excluded by type: {excluded_by_type}")
    print(f"Excluded by name: {excluded_by_name}")
    print(f"Excluded by dir: {excluded_by_dir}")
    print(f"Excluded by size: {excluded_by_size}")
    print(f"Excluded by gitignore: {excluded_by_gitignore}")
    print(f"Excluded egg-info: {excluded_egg_info}")
    print(f"Read errors: {read_errors}")
    print("---")

    if not all_contents:
        return "No relevant files found or collected.", True

    return "".join(all_contents), True


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Collect contents of text files in a project and copy to clipboard."
    )
    parser.add_argument("project_dir", nargs='?', default='.', help="Project directory (default: current)")
    parser.add_argument('-t', '--tests', action='store_true', help="Include 'tests/' directory")
    parser.add_argument('-w', '--write', action='store_true', help="Write output to 'sc2_output.txt' in project root")
    args = parser.parse_args()

    # By default exclude tests unless -t is provided
    if not args.tests:
        EXCLUDED_DIRS.add('tests')

    output, success = collect_project_contents(args.project_dir)
    if success:
        # Always copy to clipboard
        try:
            pyperclip.copy(output)
            print(f"Copied {len(output)} characters to clipboard.")
        except Exception as e:
            print(f"Warning: Could not copy to clipboard: {e}")

        # Optionally write to file
        if args.write:
            out_path = os.path.join(os.path.abspath(args.project_dir), 'sc2_output.txt')
            try:
                with open(out_path, 'w', encoding='utf-8') as f:
                    f.write(output)
                print(f"Written output to {out_path}")
            except Exception as e:
                print(f"Error writing output file: {e}")
    else:
        print(output)

--- END FILE: sc2.py ---

--- START FILE: backend/requirements.txt ---
fastapi
uvicorn[standard]
openai-agents
python-dotenv
--- END FILE: backend/requirements.txt ---

--- START FILE: backend/app/__init__.py ---

--- END FILE: backend/app/__init__.py ---

--- START FILE: backend/app/main.py ---
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from agents import Agent, Runner, function_tool
import os, asyncio

app = FastAPI()

# Allow requests from the Next.js dev server
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Example Python function exposed as a tool
@function_tool
def get_current_year() -> int:
    """Return the current year."""
    from datetime import datetime
    return datetime.now().year

class ChatRequest(BaseModel):
    user_message: str

@app.post("/chat")
async def chat(req: ChatRequest):
    # Define a simple agent – fine for early development; you can optimize later
    assistant = Agent(
        name="Assistant",
        instructions="You are a helpful assistant. Use provided tools when helpful.",
        tools=[get_current_year],
        model="gpt-4.1-nano"  # CHOSEN MODEL CHODEN MODEL CHODEN MODEL CHOSEN MODEL
    )

    try:
        # Runner.run is async; returns an AgentResult with .final_output
        result = await Runner.run(assistant, input=req.user_message)
        return {"reply": result.final_output}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
--- END FILE: backend/app/main.py ---

--- START FILE: frontend/next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

--- END FILE: frontend/next.config.ts ---

--- START FILE: frontend/README.md ---
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

--- END FILE: frontend/README.md ---

--- START FILE: frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.3.1"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "@eslint/eslintrc": "^3"
  }
}

--- END FILE: frontend/package.json ---

--- START FILE: frontend/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

--- END FILE: frontend/tsconfig.json ---

--- START FILE: frontend/app/page.tsx ---
// frontend/app/page.tsx
'use client';

import { useState } from 'react';

interface Message {
  role: 'user' | 'assistant';
  text: string;
}

export default function Home() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');

  const send = async () => {
    if (!input.trim()) return;
    const next = [...messages, { role: 'user', text: input }];
    setMessages(next);
    setInput('');

    const res = await fetch('http://localhost:8000/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ user_message: input }),
    });

    const { reply } = await res.json();
    setMessages([...next, { role: 'assistant', text: reply }]);
  };

  return (
    <main className="flex flex-col h-screen p-4">
      <section className="flex-1 overflow-y-auto space-y-2">
        {messages.map((m, i) => (
          <p key={i} className={m.role === 'user' ? 'text-blue-500' : 'text-green-500'}>
            <strong>{m.role}:</strong> {m.text}
          </p>
        ))}
      </section>

      <section className="flex pt-4">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && send()}
          className="flex-1 border rounded p-2"
          placeholder="Ask me anything…"
        />
        <button onClick={send} className="ml-2 border rounded px-3">
          Send
        </button>
      </section>
    </main>
  );
}

--- END FILE: frontend/app/page.tsx ---

--- START FILE: frontend/app/globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

--- END FILE: frontend/app/globals.css ---

--- START FILE: frontend/app/layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

--- END FILE: frontend/app/layout.tsx ---


--- END FILE: sc2_output.txt ---

--- START FILE: sc2.py ---
import os
import pyperclip
import argparse

try:
    import pathspec
except ImportError:
    pathspec = None
    print("Warning: 'pathspec' library not found. .gitignore support will be disabled.")

# --- Configuration ---

# Add file extensions you want to include (lowercase)
ALLOWED_EXTENSIONS = {
    '.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.htm', '.css', '.scss', '.sass',
    '.json', '.yaml', '.yml', '.xml', '.md', '.txt', '.sh', '.bash', '.zsh',
    '.java', '.cs', '.cpp', '.c', '.h', '.hpp', '.go', '.rs', '.php', '.rb',
    '.sql'
}

# Add specific full filenames to include regardless of extension
ALLOWED_FILENAMES = {
    'dockerfile', 'docker-compose.yml', '.env.example', '.gitignore',
    'requirements.txt', 'package.json', 'composer.json', 'pom.xml', 'gemfile'
}

# Add directory names to completely exclude (lowercase)
EXCLUDED_DIRS = {
    '.git', '.svn', '.hg', '__pycache__', 'node_modules', 'vendor', 'egg-info',
    'target', 'build', 'dist', 'out', 'bin', 'obj', '.vscode', '.idea', '.next', '.venv', 'venv', '.env', 'env'
}
EXCLUDED_DIRS = {d.lower() for d in EXCLUDED_DIRS}

# Add specific filenames to exclude (lowercase)
EXCLUDED_FILES = {
    '.env', 'credentials.json', 'secrets.yaml',
    'package-lock.json', 'yarn.lock', 'composer.lock'
}
EXCLUDED_FILES = {f.lower() for f in EXCLUDED_FILES}

# Maximum individual file size to include (in bytes)
MAX_FILE_SIZE_BYTES = 1 * 1024 * 1024  # 1 MB limit per file


def load_gitignore(project_dir):
    """
    Load .gitignore from the project directory if available.
    Returns a compiled pathspec object or None.
    """
    gitignore_path = os.path.join(project_dir, '.gitignore')
    if os.path.exists(gitignore_path) and pathspec:
        try:
            with open(gitignore_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            spec = pathspec.PathSpec.from_lines('gitwildmatch', lines)
            print("Loaded .gitignore patterns.")
            return spec
        except Exception as e:
            print(f"Error loading .gitignore: {e}")
    return None


def collect_project_contents(project_dir):
    """
    Collects relevant text file contents from a project directory.
    """
    all_contents = []
    project_dir = os.path.abspath(project_dir)

    if not os.path.isdir(project_dir):
        return f"Error: Directory not found: {project_dir}", False

    print(f"Scanning directory: {project_dir}")
    #print("Ignoring directories:", EXCLUDED_DIRS)
    #print("Ignoring files:", EXCLUDED_FILES)
    #print("Allowed extensions:", ALLOWED_EXTENSIONS)
    print("Allowed filenames:", ALLOWED_FILENAMES)
    print("---")

    gitignore_spec = load_gitignore(project_dir)

    total_files_scanned = excluded_by_type = excluded_by_name = excluded_by_dir = 0
    excluded_by_size = excluded_by_gitignore = excluded_egg_info = read_errors = included_files_count = 0

    for root, dirs, files in os.walk(project_dir, topdown=True):
        # Filter out excluded dirs immediately
        dirs[:] = [d for d in dirs if d.lower() not in EXCLUDED_DIRS]

        # Skip entire directory if any segment matches excluded dirs
        rel_root = os.path.relpath(root, project_dir)
        segments = [seg.lower() for seg in rel_root.split(os.sep) if seg]
        if set(segments) & EXCLUDED_DIRS:
            excluded_by_dir += len(dirs) + len(files)
            dirs[:] = []
            continue

        for filename in files:
            total_files_scanned += 1
            file_path = os.path.join(root, filename)
            rel_path = os.path.relpath(file_path, project_dir)

            # Skip egg-info files
            if 'egg-info' in filename.lower():
                excluded_egg_info += 1
                continue

            # Exclude specific filenames
            if filename.lower() in EXCLUDED_FILES:
                excluded_by_name += 1
                continue

            # Check extension or specific filename
            ext = os.path.splitext(filename)[1].lower()
            if ext not in ALLOWED_EXTENSIONS and filename.lower() not in ALLOWED_FILENAMES:
                excluded_by_type += 1
                continue

            # .gitignore patterns
            if gitignore_spec and gitignore_spec.match_file(rel_path):
                excluded_by_gitignore += 1
                continue

            # Size check
            try:
                size = os.path.getsize(file_path)
                if size > MAX_FILE_SIZE_BYTES:
                    excluded_by_size += 1
                    continue
            except OSError:
                read_errors += 1
                continue

            # Read content
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                header = f"--- START FILE: {rel_path} ---\n"
                footer = f"\n--- END FILE: {rel_path} ---\n\n"
                all_contents.append(header + content + footer)
                included_files_count += 1
            except Exception:
                read_errors += 1

    # Summary
    print("---")
    print(f"Total scanned: {total_files_scanned}")
    print(f"Included files: {included_files_count}")
    print(f"Excluded by type: {excluded_by_type}")
    print(f"Excluded by name: {excluded_by_name}")
    print(f"Excluded by dir: {excluded_by_dir}")
    print(f"Excluded by size: {excluded_by_size}")
    print(f"Excluded by gitignore: {excluded_by_gitignore}")
    print(f"Excluded egg-info: {excluded_egg_info}")
    print(f"Read errors: {read_errors}")
    print("---")

    if not all_contents:
        return "No relevant files found or collected.", True

    return "".join(all_contents), True


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Collect contents of text files in a project and copy to clipboard."
    )
    parser.add_argument("project_dir", nargs='?', default='.', help="Project directory (default: current)")
    parser.add_argument('-t', '--tests', action='store_true', help="Include 'tests/' directory")
    parser.add_argument('-w', '--write', action='store_true', help="Write output to 'sc2_output.txt' in project root")
    args = parser.parse_args()

    # By default exclude tests unless -t is provided
    if not args.tests:
        EXCLUDED_DIRS.add('tests')

    output, success = collect_project_contents(args.project_dir)
    if success:
        # Always copy to clipboard
        try:
            pyperclip.copy(output)
            print(f"Copied {len(output)} characters to clipboard.")
        except Exception as e:
            print(f"Warning: Could not copy to clipboard: {e}")

        # Optionally write to file
        if args.write:
            out_path = os.path.join(os.path.abspath(args.project_dir), 'sc2_output.txt')
            try:
                with open(out_path, 'w', encoding='utf-8') as f:
                    f.write(output)
                print(f"Written output to {out_path}")
            except Exception as e:
                print(f"Error writing output file: {e}")
    else:
        print(output)

--- END FILE: sc2.py ---

--- START FILE: backend/requirements.txt ---
fastapi
uvicorn[standard]
openai-agents
python-dotenv
--- END FILE: backend/requirements.txt ---

--- START FILE: backend/app/__init__.py ---

--- END FILE: backend/app/__init__.py ---

--- START FILE: backend/app/main.py ---
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from agents import Agent, Runner, function_tool
import os, asyncio

app = FastAPI()

# Allow requests from the Next.js dev server
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Example Python function exposed as a tool
@function_tool
def get_current_year() -> int:
    """Return the current year."""
    from datetime import datetime
    return datetime.now().year

class ChatRequest(BaseModel):
    user_message: str

@app.post("/chat")
async def chat(req: ChatRequest):
    # Define a simple agent – fine for early development; you can optimize later
    assistant = Agent(
        name="Assistant",
        instructions="You are a helpful assistant. Use provided tools when helpful.",
        tools=[get_current_year],
        model="gpt-4.1-nano"  # CHOSEN MODEL CHODEN MODEL CHODEN MODEL CHOSEN MODEL
    )

    try:
        # Runner.run is async; returns an AgentResult with .final_output
        result = await Runner.run(assistant, input=req.user_message)
        return {"reply": result.final_output}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
--- END FILE: backend/app/main.py ---

--- START FILE: frontend/next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

--- END FILE: frontend/next.config.ts ---

--- START FILE: frontend/README.md ---
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

--- END FILE: frontend/README.md ---

--- START FILE: frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.3.1"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.3.1",
    "@eslint/eslintrc": "^3"
  }
}

--- END FILE: frontend/package.json ---

--- START FILE: frontend/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

--- END FILE: frontend/tsconfig.json ---

--- START FILE: frontend/app/page.tsx ---
// frontend/app/page.tsx
'use client';

import { useState } from 'react';

interface Message {
  role: 'user' | 'assistant';
  text: string;
}

export default function Home() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');

  const send = async () => {
    if (!input.trim()) return;
    const next = [...messages, { role: 'user', text: input }];
    setMessages(next);
    setInput('');

    const res = await fetch('http://localhost:8000/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ user_message: input }),
    });

    const { reply } = await res.json();
    setMessages([...next, { role: 'assistant', text: reply }]);
  };

  return (
    <main className="flex flex-col h-screen p-4">
      <section className="flex-1 overflow-y-auto space-y-2">
        {messages.map((m, i) => (
          <p key={i} className={m.role === 'user' ? 'text-blue-500' : 'text-green-500'}>
            <strong>{m.role}:</strong> {m.text}
          </p>
        ))}
      </section>

      <section className="flex pt-4">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && send()}
          className="flex-1 border rounded p-2"
          placeholder="Ask me anything…"
        />
        <button onClick={send} className="ml-2 border rounded px-3">
          Send
        </button>
      </section>
    </main>
  );
}

--- END FILE: frontend/app/page.tsx ---

--- START FILE: frontend/app/globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

--- END FILE: frontend/app/globals.css ---

--- START FILE: frontend/app/layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

--- END FILE: frontend/app/layout.tsx ---

